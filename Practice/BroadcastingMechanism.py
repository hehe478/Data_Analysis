import numpy as np

# 广播 在数组运算中处理不同形状的数组
# 1. 处理标量和数组相乘
# 原本数组逐个元素相乘只能用于同形状数组，不同形状是不能的，广播使这种操作可以实现
print(np.array([1,2,3])*2)  # 这里的2，实际上运算的时候相当于[2,2,2]

# 2. 一般广播规则
# 对两个数组进行操作时，NumPy 会逐元素比较它们的形状。
# 它从末尾（即最右侧）维度开始，然后向左移动。当以下情况时，两个维度是兼容的：
# 1.它们相等
# 2.其中一个为 1（缺失的假定为1）
# 否则将会抛出异常
# 所以只要相对应的维度满足这两个条件其中之一，会将维度上元素为1的自动广播成匹配的数组
# 例如一张256*256的图像，每个像素有对应的rgb值，所以这个数组应该是256*256*3
# 若是想对这图像所有像素进行不同倍率的rgb值缩放
# 即可乘以一个维度为1包含3个元素的数组，例如[1,2,3]
# 所以可以[256,256,3] * [3]的数组
# 注意维度是右对齐，即
# 256  256  3
#           3
# 256  256  3
#      256  3
# 符合维度规则的才能广播

r = np.arange(256*256).reshape(256,256)
r1 = r[:,:,np.newaxis]
r2 = np.concatenate((r1,r1,r1),axis = 2)
r3 = np.array([1,2,3])
print(r2.shape)
print((r3 * r2).shape)

r4 = np.arange(5).reshape(5,1)
r5 = np.arange(6).reshape(1,6)
r6 = np.arange(6)
print((r4*r5*r6).shape)
print((r6 - r5).shape)
print((r5 * r6).shape)

#  例题
# `observation` 中的值描述了待分类运动员的体重和身高。`codes` 代表不同类别的运动员。
# 找到最近的点需要计算 `observation` 与每个 `codes` 之间的距离。最短距离提供最佳匹配。
observation = np.array([111.0, 188.0])
codes = np.array([[102.0, 203.0],
               [132.0, 193.0],
               [45.0, 155.0],
               [57.0, 173.0]])
diff = codes - observation    # the broadcast happens here
dist = np.sqrt(np.sum(diff**2,axis=-1)) # 求平方和，距离最小值，不过实际应用中最好对身高体重进行标准化，再这样计算处理
np.argmin(dist)   # 找到最小值的索引

# 注意
# 广播是一个强大的工具，用于编写简洁且通常直观的代码，这些代码在 C 语言中高效地执行计算。
# 然而，在某些情况下，广播会为特定算法使用不必要的过大内存量。在这些情况下，最好在 Python 中编写算法的外部循环。
# 这可能还会生成更具可读性的代码，因为随着广播维度数量的增加，使用广播的算法往往变得更难以理解。
# 例如
# Observation (10 x 3)：表示有 10 个观测点，每个观测点有 3 个特征（比如三维空间中的坐标）。
# Codes (5 x 1 x 3)：表示有 5 个参考组，每个组内有 1 个参考点（形状中的1是为了触发广播），每个参考点也有 3 个特征。
# Diff (5 x 10 x 3)：广播后的结果，是Codes与Observations逐元素相减的数组。形状含义：5个参考组 × 10个观测点 × 每个点的3个特征差值。
# 如果改用Python 循环逐个处理观测点：
# 每次循环只取1 个观测点（形状(1, 3)），与Codes (5, 1, 3)计算Diff。
# 此时生成的Diff是(5, 1, 3)（远小于广播后的5 x 10 x 3），计算完成后释放内存，再处理下一个观测点。
# 虽然 Python 循环本身有 “解释型语言的开销”，但每次仅操作小批量数据，内存占用极低，
# 在 “数据量极大且内存受限” 的场景下，反而能避免内存溢出，甚至整体更高效。